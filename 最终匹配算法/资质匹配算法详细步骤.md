# 资质匹配算法详细步骤

## 1. 算法概述

资质匹配算法的核心目标是根据用户选择的多个资质，计算出满足所有资质要求的最小职称人员配置。算法考虑了两种类型的资质要求：

- **要求齐全的资质**：每个职称类型至少需要1人，且总人数达到要求
- **不要求齐全的资质**：只需总人数达到要求，职称类型可以不齐全

## 2. 算法输入

- 用户选择的多个资质名称
- 资质数据库（包含每个资质的要求：职称类型、是否要求齐全、总人数要求）

## 3. 算法输出

- 最终所需的各职称类型及人数
- 各职称类型的属性（是否为共享或有齐全要求）
- 总人数

## 4. 算法详细步骤

### 步骤1：接收用户输入并匹配资质

1.1 接收用户通过前端界面选择的资质名称
1.2 对每个资质名称进行模糊搜索匹配，确保输入的资质名称能正确匹配到数据库中的资质
1.3 收集所有匹配成功的资质信息，形成待处理的资质列表

### 步骤2：初始化职称计数和资质满足状态

2.1 创建空的职称计数字典 `final_counts`，用于存储最终每个职称类型所需的人数
2.2 创建资质满足状态字典 `satisfied`，初始时所有资质的满足状态为 `False`

### 步骤3：处理有齐全要求的资质

3.1 遍历所有资质，识别出 `require_all_types` 为 `True` 的资质
3.2 对于每个要求齐全的资质，为其包含的每个职称类型在 `final_counts` 中设置至少1人

### 步骤4：检查初始满足状态

4.1 定义 `check_satisfied()` 函数，用于检查各资质是否已满足要求：
   - 对于要求齐全的资质：检查每个职称类型至少1人，且总人数达到要求
   - 对于不要求齐全的资质：仅检查总人数是否达到要求
4.2 调用 `check_satisfied()` 函数，更新各资质的满足状态

### 步骤5：循环优化职称分配

5.1 当存在未满足的资质时，进入循环：
   - 统计当前未满足资质中每个职称类型的共享次数
   - 选择当前缺口最小的资质优先处理
   - 计算该资质还需要的人数
   - 按共享次数从多到少的顺序，将需要的人数分配到相应的职称类型上
   - 每次分配后重新检查所有资质的满足状态
   - 若该资质已满足，跳出当前资质的分配循环

### 步骤6：优化职称数量

6.1 定义 `optimize_counts()` 函数，用于优化职称数量，确保总人数最少：
   - 按当前人数从多到少排序所有职称类型
   - 尝试减少每个职称类型的人数（至少保留1人）
   - 检查减少后是否仍满足所有资质要求
   - 若满足则保留减少后的数量，否则恢复原数量
6.2 调用 `optimize_counts()` 函数，优化最终职称数量

### 步骤7：验证并调整结果

7.1 定义 `validate_and_adjust()` 函数，用于最终验证和调整：
   - 分离有齐全要求和无齐全要求的资质
   - 按单个要求人数从小到大排序有齐全要求的资质
   - 处理有齐全要求的资质：确保每个职称类型至少1人，且总人数满足要求
   - 处理无齐全要求的资质：确保总人数满足要求
   - 最终验证所有资质要求都被满足
7.2 调用 `validate_and_adjust()` 函数，确保结果的正确性

### 步骤8：再次优化并生成属性

8.1 再次调用 `optimize_counts()` 函数，确保总人数最少
8.2 生成各职称类型的属性：
   - 检查是否来自有齐全要求的资质
   - 检查是否为共享职称（在多个资质中出现）
   - 确定背景颜色：淡红色（有齐全要求或共享）或淡绿色（仅无齐全要求且不共享）

### 步骤9：返回结果

9.1 计算总人数
9.2 将最终结果返回给前端：
   - 最终所需职称数量
   - 各职称类型的属性
   - 总人数

## 5. 算法特点

### 5.1 优化目标

- **最小化总人数**：通过多次优化，确保在满足所有资质要求的前提下，总人数最少
- **优先考虑共享职称**：共享次数多的职称优先分配，提高资源利用率
- **优先处理缺口小的资质**：先解决容易满足的资质，再处理复杂的资质

### 5.2 处理逻辑

- **分层处理**：区分有齐全要求和无齐全要求的资质，分别处理
- **动态调整**：根据当前状态动态调整职称分配
- **严格验证**：确保最终结果满足所有资质要求

## 6. 算法流程图

```
开始
  |
  v
接收用户输入资质名称
  |
  v
模糊匹配资质到数据库
  |
  v
初始化职称计数和满足状态
  |
  v
处理有齐全要求的资质（每个职称至少1人）
  |
  v
检查初始满足状态
  |
  v
┌─────────────────────────────────────────┐
│ 循环：存在未满足的资质？                │
└─────────┬───────────────────────────────┘
          │ 是
          v
统计未满足资质的职称共享次数
          │
          v
选择缺口最小的资质优先处理
          │
          v
计算还需要的人数
          │
          v
按共享次数分配人数到职称类型
          │
          v
检查并更新满足状态
          │
          v
└─────────────────────────────────────────┘
          │ 否
          v
优化职称数量（减少不必要的人数）
          │
          v
验证并调整结果
          │
          v
再次优化职称数量
          │
          v
生成职称类型属性
          │
          v
计算总人数
          │
          v
返回最终结果给前端
  |
  v
结束
```

## 7. 算法优化点

### 7.1 共享次数统计优化

- 仅统计未满足资质中的职称共享次数，减少计算量
- 按共享次数排序，优先分配到共享次数多的职称上

### 7.2 缺口计算优化

- 选择缺口最小的资质优先处理，提高算法效率
- 每次分配后立即检查满足状态，避免不必要的计算

### 7.3 结果优化

- 多次优化，确保总人数最少
- 尝试减少每个职称类型的人数，检查是否仍满足要求
- 严格验证，确保结果的正确性

## 8. 算法应用场景

- 建筑企业资质升级或增项时，计算所需的职称人员配置
- 企业资质维护时，检查现有人员是否满足资质要求
- 人力资源规划时，根据资质要求制定招聘计划

## 9. 算法性能分析

- 时间复杂度：O(n^2)，其中n为资质数量
- 空间复杂度：O(m)，其中m为所有资质包含的职称类型总数
- 对于常见的资质数量（1-10个），算法运行速度快，能够实时响应用户请求

## 10. 算法改进方向

- 考虑职称之间的替代关系，允许某些职称类型之间相互替代
- 引入权重机制，根据职称的稀缺性或成本调整分配策略
- 支持更复杂的资质要求，如职称等级、工作年限等
- 优化算法，支持更多数量的资质同时匹配
