```mermaid
flowchart TD
    A[开始] --> B[接收用户输入资质名称]
    B --> C[模糊匹配资质到数据库]
    C --> D[初始化职称计数和满足状态]
    D --> E[处理有齐全要求的资质]
    E --> F[检查初始满足状态]
    F --> G{存在未满足的资质?}
    G -->|是| H[统计未满足资质的职称共享次数]
    H --> I[选择缺口最小的资质优先处理]
    I --> J[计算还需要的人数]
    J --> K[按共享次数分配人数到职称类型]
    K --> L[检查并更新满足状态]
    L --> G
    G -->|否| M[优化职称数量]
    M --> N[验证并调整结果]
    N --> O[再次优化职称数量]
    O --> P[生成职称类型属性]
    P --> Q[计算总人数]
    Q --> R[返回最终结果给前端]
    R --> S[结束]

    subgraph 资质匹配核心流程
        B --> C --> D --> E --> F --> G --> H --> I --> J --> K --> L
    end

    subgraph 结果优化与验证
        M --> N --> O --> P --> Q --> R
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style S fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#ff9,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px
    style M fill:#bbf,stroke:#333,stroke-width:2px
    style N fill:#bbf,stroke:#333,stroke-width:2px
```

# 资质匹配算法流程图说明

## 主要流程

1. **开始**：算法执行的起始点
2. **接收用户输入资质名称**：从前端获取用户选择的资质列表
3. **模糊匹配资质到数据库**：使用模糊搜索算法将用户输入的资质名称匹配到数据库中的具体资质
4. **初始化职称计数和满足状态**：
   - 创建空的职称计数字典 `final_counts`
   - 创建资质满足状态字典 `satisfied`，初始值为 `False`
5. **处理有齐全要求的资质**：
   - 识别所有 `require_all_types` 为 `True` 的资质
   - 为每个要求齐全的资质的所有职称类型设置至少1人
6. **检查初始满足状态**：
   - 检查各资质是否已满足要求
   - 更新资质满足状态字典
7. **循环处理未满足的资质**：
   - 统计未满足资质中每个职称类型的共享次数
   - 选择缺口最小的资质优先处理
   - 计算还需要的人数
   - 按共享次数从多到少分配人数
   - 每次分配后重新检查满足状态
   - 直到所有资质都满足要求
8. **优化职称数量**：
   - 尝试减少每个职称类型的人数（至少保留1人）
   - 检查减少后是否仍满足所有资质要求
   - 保留最优结果
9. **验证并调整结果**：
   - 分离有齐全要求和无齐全要求的资质
   - 按单个要求人数从小到大排序有齐全要求的资质
   - 处理有齐全要求的资质：确保每个职称类型至少1人，且总人数满足要求
   - 处理无齐全要求的资质：确保总人数满足要求
   - 最终验证所有资质要求都被满足
10. **再次优化职称数量**：确保总人数最少
11. **生成职称类型属性**：
    - 检查是否来自有齐全要求的资质
    - 检查是否为共享职称
    - 确定背景颜色属性
12. **计算总人数**：统计所有职称类型的人数之和
13. **返回最终结果给前端**：将计算结果返回给前端展示
14. **结束**：算法执行结束

## 流程图特点

- 使用不同颜色区分核心流程和结果优化与验证阶段
- 清晰展示了算法的循环结构
- 突出了关键决策点
- 详细描述了每个步骤的主要操作

## 如何使用此流程图

1. 可以使用支持mermaid的工具（如VS Code的mermaid插件、GitHub、GitLab等）直接渲染此流程图
2. 可以将此流程图导出为图片格式，用于文档或演示
3. 可以根据需要修改流程图，添加或调整步骤

## 算法优化点在流程图中的体现

1. **优先处理缺口小的资质**：通过选择缺口最小的资质优先处理，提高算法效率
2. **优先分配共享次数多的职称**：通过统计共享次数，优先分配到共享次数多的职称上，提高资源利用率
3. **多次优化结果**：通过两次优化职称数量，确保在满足所有资质要求的前提下，总人数最少
4. **严格验证**：通过最终验证，确保结果的正确性

## 算法复杂度分析

- **时间复杂度**：O(n^2)，其中n为资质数量
- **空间复杂度**：O(m)，其中m为所有资质包含的职称类型总数
- 对于常见的资质数量（1-10个），算法运行速度快，能够实时响应用户请求
